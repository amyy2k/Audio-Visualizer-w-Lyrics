<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wireframe Audio Visualizer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: linear-gradient(to bottom, #ff6b35, #ffa726);
            color: #fff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            gap: 15px;
            align-items: center;
            background: rgba(255, 107, 53, 0.2);
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        select, button, input[type="range"] {
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.6);
            padding: 8px 12px;
            font-family: inherit;
            border-radius: 5px;
        }
        
        button:hover, select:hover {
            background: rgba(255, 140, 66, 0.4);
            border-color: #fff;
        }
        
        #playBtn {
            min-width: 60px;
        }
        
        #volume {
            width: 100px;
        }
        
        #fileInput {
            display: none;
        }
        
        #status {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 107, 53, 0.2);
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="ui">
        <select id="trackSelect">
            <option value="">Choose a track...</option>
            <option value="./Cynthoni - Dork After Dark.mp3">Cynthoni - Dork After Dark</option>
            <option value="./Cynthoni - Lychee Ice.mp3">Cynthoni - Lychee Ice</option>
            <option value="./Joji - Die For You.mp3">Joji - Die For You</option>
            <option value="./Porter Robinson - Sad Machine.mp3">Porter Robinson - Sad Machine</option>
            <option value="./Radiohead - All I Need.mp3">Radiohead - All I Need</option>
        </select>
        
        <button id="uploadBtn">Upload File</button>
        <input type="file" id="fileInput" accept="audio/*">
        
        <button id="playBtn">▶ Play</button>
        
        <label>Volume:</label>
        <input type="range" id="volume" min="0" max="100" value="50">
    </div>
    
    <div id="status">Welcome to the beach - Click a track to begin</div>
    
    <audio id="audio"></audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer, terrain, sun;
        let audioContext, analyser, audioSource, dataArray;
        let isPlaying = false;
        let currentTrack = null;
        
        // UI elements
        const audio = document.getElementById('audio');
        const trackSelect = document.getElementById('trackSelect');
        const uploadBtn = document.getElementById('uploadBtn');
        const fileInput = document.getElementById('fileInput');
        const playBtn = document.getElementById('playBtn');
        const volumeSlider = document.getElementById('volume');
        const status = document.getElementById('status');
        
        // Initialize Three.js scene
        function initScene() {
            // Scene setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Create sunset gradient background
            createSunsetSky();
            
            document.body.appendChild(renderer.domElement);
            
            // Camera position - lower and more forward for landscape view
            camera.position.set(0, 20, 200);
            camera.lookAt(0, 0, -200);
            
            // Create wireframe terrain
            createTerrain();
            
            // Create sunset sun
            createSun();
            
            // Add atmospheric lighting
            createLighting();
            
            // Start animation loop
            animate();
            
            status.textContent = "Beach sunset scene initialized - Select a track";
        }
        
        function createSunsetSky() {
            // Create gradient background using canvas
            const canvas = document.createElement('canvas');
            canvas.width = 2;
            canvas.height = 256;
            const context = canvas.getContext('2d');
            
            // Create sunset gradient
            const gradient = context.createLinearGradient(0, 0, 0, 256);
            gradient.addColorStop(0, '#ff6b35');    // Orange top
            gradient.addColorStop(0.3, '#ff8c42');  // Orange-pink
            gradient.addColorStop(0.6, '#ffa726');  // Yellow-orange
            gradient.addColorStop(0.8, '#ffb74d');  // Light orange
            gradient.addColorStop(1, '#ffe0b2');    // Pale orange bottom
            
            context.fillStyle = gradient;
            context.fillRect(0, 0, 2, 256);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.mapping = THREE.EquirectangularReflectionMapping;
            scene.background = texture;
        }
        
        function createLighting() {
            // Ambient light for overall scene illumination
            const ambientLight = new THREE.AmbientLight(0xffa726, 0.4);
            scene.add(ambientLight);
            
            // Directional light simulating sunset
            const sunsetLight = new THREE.DirectionalLight(0xff6b35, 0.8);
            sunsetLight.position.set(-1, 1, -1);
            scene.add(sunsetLight);
        }
        
        function createTerrain() {
            const geometry = new THREE.PlaneGeometry(800, 800, 100, 100);
            geometry.rotateX(-Math.PI / 2);
            
            // Create initial flowing landscape
            const positions = geometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const z = positions.getZ(i);
                
                // Create flowing hills and valleys like ocean waves
                const wave1 = Math.sin(x * 0.01) * 20;
                const wave2 = Math.cos(z * 0.008) * 15;
                const wave3 = Math.sin((x + z) * 0.005) * 25;
                const noise = Math.random() * 5;
                
                const height = wave1 + wave2 + wave3 + noise;
                positions.setY(i, height);
            }
            
            // Blue ocean-like wireframe material
            const material = new THREE.MeshBasicMaterial({
                color: 0x0077be,  // Ocean blue
                wireframe: true,
                transparent: true,
                opacity: 0.9
            });
            
            terrain = new THREE.Mesh(geometry, material);
            scene.add(terrain);
        }
        
        function createSun() {
            // Main sunset sun sphere
            const sunGeometry = new THREE.SphereGeometry(25, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({
                color: 0xffa500,  // Sunset orange
                transparent: false,
                opacity: 1.0
            });
            
            sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.position.set(0, 150, -300);
            scene.add(sun);
            
            // Sunset glow effect with warm colors
            const glowColors = [0xffb347, 0xff8c42, 0xff6b35, 0xff5722]; // Warm sunset colors
            
            for (let i = 1; i <= 4; i++) {
                const glowGeometry = new THREE.SphereGeometry(25 + (i * 15), 32, 32);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: glowColors[i - 1],
                    transparent: true,
                    opacity: 0.2 / i
                });
                
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.copy(sun.position);
                scene.add(glow);
                
                // Store glow references on sun object
                if (!sun.glows) sun.glows = [];
                sun.glows.push(glow);
            }
            
            // Warm sunset point light
            const light = new THREE.PointLight(0xffa500, 3, 500);
            light.position.copy(sun.position);
            scene.add(light);
            sun.light = light;
        }
        
        // Audio functions
        async function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                
                // Create analyser
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 128;
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                
                return true;
            } catch (error) {
                console.error('Audio context error:', error);
                status.textContent = "Audio initialization failed";
                return false;
            }
        }
        
        function loadAudio(src) {
            return new Promise((resolve, reject) => {
                audio.src = src;
                audio.load();
                
                const onLoad = () => {
                    audio.removeEventListener('canplaythrough', onLoad);
                    audio.removeEventListener('error', onError);
                    resolve();
                };
                
                const onError = () => {
                    audio.removeEventListener('canplaythrough', onLoad);
                    audio.removeEventListener('error', onError);
                    reject(new Error('Failed to load audio'));
                };
                
                audio.addEventListener('canplaythrough', onLoad);
                audio.addEventListener('error', onError);
            });
        }
        
        async function setupAudioSource() {
            if (audioSource) {
                audioSource.disconnect();
            }
            
            try {
                audioSource = audioContext.createMediaElementSource(audio);
                audioSource.connect(analyser);
                analyser.connect(audioContext.destination);
                return true;
            } catch (error) {
                // If source already exists, just reconnect
                try {
                    audioSource.connect(analyser);
                    analyser.connect(audioContext.destination);
                    return true;
                } catch (reconnectError) {
                    console.error('Audio source setup failed:', error);
                    return false;
                }
            }
        }
        
        async function playTrack(src) {
            try {
                status.textContent = "Loading track...";
                
                // Initialize audio if needed
                if (!audioContext) {
                    const audioOK = await initAudio();
                    if (!audioOK) return;
                }
                
                // Load the audio file
                await loadAudio(src);
                
                // Setup audio source for analysis
                const sourceOK = await setupAudioSource();
                if (!sourceOK) {
                    status.textContent = "Audio source setup failed";
                    return;
                }
                
                // Update UI
                currentTrack = src;
                playBtn.textContent = "▶ Play";
                status.textContent = "Track loaded - Ready to play";
                
            } catch (error) {
                console.error('Error loading track:', error);
                status.textContent = "Error loading track: " + error.message;
            }
        }
        
        async function togglePlay() {
            if (!currentTrack) {
                status.textContent = "No track selected";
                return;
            }
            
            try {
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                
                if (audio.paused) {
                    await audio.play();
                    playBtn.textContent = "⏸ Pause";
                    isPlaying = true;
                    status.textContent = "Playing";
                } else {
                    audio.pause();
                    playBtn.textContent = "▶ Play";
                    isPlaying = false;
                    status.textContent = "Paused";
                }
            } catch (error) {
                console.error('Playback error:', error);
                status.textContent = "Playback error: " + error.message;
            }
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update visualization if audio is playing
            if (isPlaying && analyser && dataArray) {
                updateVisualization();
            } else {
                // Gentle flowing animation when no audio
                animateIdle();
            }
            
            // Subtle camera movement for immersion
            const time = Date.now() * 0.0005;
            camera.position.x = Math.sin(time) * 10;
            camera.lookAt(Math.sin(time * 0.5) * 20, 0, -200);
            
            renderer.render(scene, camera);
        }
        
        function animateIdle() {
            // Gentle flowing ocean waves when not playing music
            const positions = terrain.geometry.attributes.position;
            const time = Date.now() * 0.001;
            
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const z = positions.getZ(i);
                
                // Gentle flowing ocean waves
                const wave1 = Math.sin(x * 0.01 + time * 0.5) * 20;
                const wave2 = Math.cos(z * 0.008 + time * 0.3) * 15;
                const wave3 = Math.sin((x + z) * 0.005 + time * 0.2) * 25;
                
                const height = wave1 + wave2 + wave3;
                positions.setY(i, height);
            }
            
            positions.needsUpdate = true;
            
            // Gentle sun pulsing
            const pulse = Math.sin(time * 0.5) * 0.1 + 1;
            sun.scale.set(pulse, pulse, pulse);
            
            // Maintain sunset colors
            terrain.material.color.setRGB(0, 0.47, 0.75); // Ocean blue
            sun.material.color.setRGB(1, 0.65, 0); // Sunset orange
        }
        
        function updateVisualization() {
            analyser.getByteFrequencyData(dataArray);
            
            // Check if we have actual audio data
            const hasData = dataArray.some(value => value > 0);
            if (!hasData) return;
            
            // Calculate overall audio intensity
            const overallIntensity = dataArray.reduce((a, b) => a + b, 0) / (dataArray.length * 255);
            
            // Update terrain based on frequency data with flowing waves
            const positions = terrain.geometry.attributes.position;
            const time = Date.now() * 0.001;
            
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const z = positions.getZ(i);
                
                // Map position to frequency data
                const normalizedX = (x + 400) / 800; // Normalize to 0-1
                const normalizedZ = (z + 400) / 800;
                
                // Get frequency data for this position
                const freqIndex = Math.floor(normalizedX * dataArray.length);
                const audioValue = dataArray[Math.min(freqIndex, dataArray.length - 1)] || 0;
                const intensity = audioValue / 255;
                
                // Create flowing base landscape like ocean waves
                const baseWave1 = Math.sin(x * 0.01 + time * 2) * 20;
                const baseWave2 = Math.cos(z * 0.008 + time * 1.5) * 15;
                const baseWave3 = Math.sin((x + z) * 0.005 + time) * 25;
                
                // Add audio-reactive waves
                const audioWave1 = Math.sin(x * 0.02 + time * 3) * intensity * 40;
                const audioWave2 = Math.cos(z * 0.015 + time * 2.5) * intensity * 30;
                const audioWave3 = Math.sin((x - z) * 0.01 + time * 4) * intensity * 35;
                
                // Combine waves for flowing ocean effect
                const height = baseWave1 + baseWave2 + baseWave3 + 
                              audioWave1 + audioWave2 + audioWave3;
                
                positions.setY(i, height);
            }
            
            positions.needsUpdate = true;
            
            // Make waves more vibrant blue during intense music
            const blueIntensity = Math.min(1, 0.6 + (overallIntensity * 0.4));
            terrain.material.color.setRGB(0, 0.47 * blueIntensity, 0.75 * blueIntensity);
            
            // Update sunset sun based on bass frequencies
            const bassData = dataArray.slice(0, 10);
            const bassAverage = bassData.reduce((a, b) => a + b, 0) / bassData.length;
            const bassIntensity = bassAverage / 255;
            
            // Scale sun with dramatic sunset effect
            const scale = 1 + (bassIntensity * 2);
            sun.scale.set(scale, scale, scale);
            
            // Make sun more intense orange during bass hits
            const sunIntensity = Math.min(1, 0.8 + (bassIntensity * 0.2));
            sun.material.color.setRGB(1, 0.65 * sunIntensity, 0);
            
            // Update glow layers with sunset colors
            if (sun.glows) {
                sun.glows.forEach((glow, index) => {
                    const glowScale = scale + (index * 0.3);
                    glow.scale.set(glowScale, glowScale, glowScale);
                    glow.material.opacity = (0.2 / (index + 1)) * (1 + bassIntensity * 2);
                });
            }
            
            // Update warm sunset light intensity
            if (sun.light) {
                sun.light.intensity = 3 + (bassIntensity * 5);
            }
        }
        
        // Event listeners
        trackSelect.addEventListener('change', (e) => {
            if (e.target.value) {
                playTrack(e.target.value);
            }
        });
        
        uploadBtn.addEventListener('click', () => {
            fileInput.click();
        });
        
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                playTrack(url);
                
                // Add to dropdown
                const option = document.createElement('option');
                option.value = url;
                option.textContent = file.name;
                trackSelect.appendChild(option);
                trackSelect.value = url;
            }
        });
        
        playBtn.addEventListener('click', togglePlay);
        
        volumeSlider.addEventListener('input', (e) => {
            audio.volume = e.target.value / 100;
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Initialize when page loads
        window.addEventListener('load', () => {
            initScene();
            audio.volume = 0.5; // Set initial volume
        });
        
        // Handle audio end
        audio.addEventListener('ended', () => {
            playBtn.textContent = "▶ Play";
            isPlaying = false;
            status.textContent = "Track ended";
        });
    </script>
</body>
</html>
